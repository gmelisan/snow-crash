//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <fcntl.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int32_t afterSubstr(int32_t a1, int32_t a2);
int32_t ft_des(char * str);
int32_t function_8048500(char * file, int32_t oflag, ...);
int32_t isLib(int32_t * a1, char * a2);
int32_t syscall_gets(int32_t * a1, int32_t a2, int32_t fd);
int32_t syscall_open(char * a1, int32_t a2);

// --------------------- Global Variables ---------------------

char (*g1)[5] = ".so\n"; // 0x804b038
struct _IO_FILE * g2 = NULL; // 0x804b040
struct _IO_FILE * g3 = NULL; // 0x804b060
int32_t g4;

// ------------------------ Functions -------------------------

// Address range: 0x8048500 - 0x8048506
int32_t function_8048500(char * file, int32_t oflag, ...) {
    // 0x8048500
    return open();
}

// Address range: 0x8048604 - 0x804871c
int32_t ft_des(char * str) {
    int32_t result = (int32_t)strdup(str);
    uint32_t v1 = 0;
    int32_t v2 = 0;
    int32_t v3 = result; // 0x8048701
    int32_t v4 = -1;
    int32_t v5 = 0; // 0x8048701
    int32_t v6; // 0x8048604
    bool v7; // 0x8048604
    int32_t v8; // 0x8048701
    while (v4 != 0) {
        v6 = v3;
        v8 = v4 - 1;
        v3 = v6 + (v7 ? -1 : 1);
        v5 = v8;
        if (*(char *)v6 == 0) {
            // break ->
            break;
        }
        v4 = v8;
        v5 = 0;
    }
    while (-2 - v5 > v1) {
        int32_t v9 = v2 != 6 ? v2 : 0;
        char * v10 = (char *)(v9 + (int32_t)"0123456");
        char v11 = *v10;
        if (v1 % 2 == 0) {
            if (v11 > 0) {
                char * v12 = (char *)(v1 + result); // 0x80486aa
                char v13 = *v12;
                for (int32_t i = 0; i < (int32_t)*v10; i++) {
                    char v14 = v13 - 1; // 0x80486ad
                    v13 = v14 != 31 ? v14 : 126;
                    *v12 = v13;
                }
            }
        } else {
            if (v11 > 0) {
                char * v15 = (char *)(v1 + result); // 0x8048654
                char v16 = *v15;
                for (int32_t i = 0; i < (int32_t)*v10; i++) {
                    char v17 = v16 + 1; // 0x8048657
                    v16 = v17 != 127 ? v17 : 32;
                    *v15 = v16;
                }
            }
        }
        // 0x80486e3
        v1++;
        v2 = v9 + 1;
        v3 = result;
        v4 = -1;
        v5 = 0;
        while (v4 != 0) {
            v6 = v3;
            v8 = v4 - 1;
            v3 = v6 + (v7 ? -1 : 1);
            v5 = v8;
            if (*(char *)v6 == 0) {
                // break ->
                break;
            }
            v4 = v8;
            v5 = 0;
        }
    }
    // 0x8048713
    return result;
}

// Address range: 0x804871c - 0x804874c
int32_t syscall_open(char * a1, int32_t a2) {
    // 0x804871c
    return open();
}

// Address range: 0x804874c - 0x80487be
int32_t syscall_gets(int32_t * a1, int32_t a2, int32_t fd) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = 0; // 0x804875b
    int32_t result = v2; // 0x80487a4
    while (a2 - 1 > v2) {
        int32_t buf = v2 + v1; // 0x8048763
        result = v2;
        if (read(fd, (int32_t *)buf, 1) != 1) {
            // break -> 0x80487a9
            break;
        }
        // 0x8048782
        v2++;
        result = v2;
        if (*(char *)buf == 10) {
            // break -> 0x80487a9
            break;
        }
        result = v2;
    }
    // 0x80487a9
    *(char *)(result + v1) = 0;
    return result;
}

// Address range: 0x80487be - 0x8048843
int32_t afterSubstr(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // 0x8048829
    int32_t v2 = a1; // 0x8048829
    int32_t v3 = 0; // 0x8048829
    int32_t v4; // 0x80487be
    if (*(char *)a1 == 0) {
      lab_0x804882e:
        // 0x804882e
        return v3 != 0 ? v4 + v2 : 0;
    }
    int32_t v5 = 0; // 0x80487be
    int32_t v6 = 1; // 0x80487be
    char v7 = *(char *)(v5 + a2); // 0x8048810
    v2 = v1;
    v4 = v5;
    v3 = v6;
    if (v7 == 0) {
        return v3 != 0 ? v4 + v2 : 0;
    }
    char v8 = *(char *)(v5 + v1); // 0x80487f2
    int32_t v9 = v7 == v8 ? v6 : 0;
    int32_t v10 = v5 + 1; // 0x8048800
    v5 = v10;
    v6 = v9;
    while (v9 == 1) {
        // 0x804880a
        v7 = *(char *)(v5 + a2);
        v2 = v1;
        v4 = v5;
        v3 = v6;
        if (v7 == 0) {
            return v3 != 0 ? v4 + v2 : 0;
        }
        // 0x80487e3
        v8 = *(char *)(v5 + v1);
        v9 = v7 == v8 ? v6 : 0;
        v10 = v5 + 1;
        v5 = v10;
        v6 = v9;
    }
    // 0x804881d
    v1++;
    while (*(char *)v1 != 0) {
        // 0x8048804
        v5 = 0;
        v6 = 1;
        v7 = *(char *)(v5 + a2);
        v2 = v1;
        v4 = v5;
        v3 = v6;
        if (v7 == 0) {
            return v3 != 0 ? v4 + v2 : 0;
        }
        // 0x80487e3
        v8 = *(char *)(v5 + v1);
        v9 = v7 == v8 ? v6 : 0;
        v10 = v5 + 1;
        v5 = v10;
        v6 = v9;
        while (v9 == 1) {
            // 0x804880a
            v7 = *(char *)(v5 + a2);
            v2 = v1;
            v4 = v5;
            v3 = v6;
            if (v7 == 0) {
                return v3 != 0 ? v4 + v2 : 0;
            }
            // 0x80487e3
            v8 = *(char *)(v5 + v1);
            v9 = v7 == v8 ? v6 : 0;
            v10 = v5 + 1;
            v5 = v10;
            v6 = v9;
        }
        // 0x804881d
        v1++;
    }
    // 0x804882e
    return v9 != 0 ? v10 + v1 : 0;
}

// Address range: 0x8048843 - 0x8048946
int32_t isLib(int32_t * a1, char * a2) {
    int32_t v1 = afterSubstr((int32_t)a1, (int32_t)a2); // 0x8048856
    if (v1 == 0) {
        // 0x8048944
        return 0;
    }
    char * v2 = (char *)v1; // 0x804885b
    if (*v2 != 45) {
        // 0x8048944
        return 0;
    }
    char * v3 = v2; // 0x8048876
    int32_t v4 = 0;
    v3 = (char *)((int32_t)v3 + 1);
    char v5 = *v3; // 0x804889d
    while (v5 < 58) {
        // 0x804889a
        v4 = 1;
        v3 = (char *)((int32_t)v3 + 1);
        v5 = *v3;
    }
    // 0x80488ae
    if (v4 != 0 != (v5 == 46)) {
        // 0x8048944
        return 0;
    }
    int32_t v6 = 0;
    int32_t v7 = (int32_t)v3 + 1;
    char * v8 = (char *)v7;
    while (*v8 < 58) {
        // 0x80488dd
        v6 = 1;
        v7 = (int32_t)v8 + 1;
        v8 = (char *)v7;
    }
    // 0x80488f1
    if (v6 == 0) {
        // 0x8048944
        return 0;
    }
    char v9 = g1[0]; // 0x8048938
    if (v9 == 0) {
        // 0x8048944
        return 1;
    }
    char v10 = v9; // 0x8048938
    int32_t v11 = 0; // 0x8048929
    int32_t result = 0; // 0x8048920
    while (v10 == *(char *)(v11 + v7)) {
        // 0x804892d
        v11++;
        v10 = *(char *)(v11 + (int32_t)g1);
        result = 1;
        if (v10 == 0) {
            // break -> 0x8048944
            break;
        }
        result = 0;
    }
    // 0x8048944
    return result;
}

// Address range: 0x8048946 - 0x8048ecc
int main(int argc, char ** argv) {
    int32_t v1 = __readgsdword(20); // 0x8048953
    int32_t v2; // 0x8048946
    if (ptrace(0) >= 0) {
        // 0x80489a8
        if (getenv("LD_PRELOAD") == NULL) {
            // 0x80489ea
            if (function_8048500("/etc/ld.so.preload", 0) < 1) {
                int32_t v3 = syscall_open("/proc/self/maps", 0); // 0x8048a43
                if (v3 != -1) {
                    int32_t v4 = 0; // 0x8048946
                    while (true) {
                        int32_t v5; // bp-276, 0x8048946
                        int32_t v6 = syscall_gets(&v5, 256, v3); // 0x8048ea0
                        v2 = 0;
                        if (v6 == 0) {
                            // break (via goto) -> 0x8048eb2
                            goto lab_0x8048eb2;
                        }
                        int32_t v7 = isLib(&v5, "libc"); // 0x8048a98
                        // 0x8048e89
                        while (v4 != 0 && v7 == 0) {
                            // 0x8048ab9
                            if (isLib(&v5, "ld") != 0) {
                                // 0x8048ad5
                                fwrite((int32_t *)"Check flag.Here is your token : ", 1, 32, g3);
                                uint32_t v8 = getuid(); // 0x8048afd
                                if (v8 == 3006) {
                                    // 0x8048ccb
                                    fputs((char *)ft_des("H8B8h_20B4J43><8>\\ED<;j@3"), g3);
                                    goto lab_0x8048e2f;
                                } else {
                                    if (v8 < 3007) {
                                        if (v8 == 3002) {
                                            // 0x8048c3b
                                            fputs((char *)ft_des("<>B16\\AD<C6,G_<1>^7ci>l4B"), g3);
                                            goto lab_0x8048e2f;
                                        } else {
                                            if (v8 < 3003) {
                                                if (v8 == 3000) {
                                                    // 0x8048bf3
                                                    fputs((char *)ft_des("I`fA>_88eEd:=`85h0D8HE>,D"), g3);
                                                    goto lab_0x8048e2f;
                                                } else {
                                                    if (v8 < 3001) {
                                                        if (v8 == 0) {
                                                            // 0x8048bc6
                                                            fwrite((int32_t *)"You are root are you that dumb ?\n", 1, 33, g3);
                                                            goto lab_0x8048e2f;
                                                        } else {
                                                            // 0x8048e06
                                                            fwrite((int32_t *)"\nNope there is no token here for you sorry. Try again :)", 1, 56, g3);
                                                            goto lab_0x8048e2f;
                                                        }
                                                    } else {
                                                        // 0x8048c17
                                                        fputs((char *)ft_des("7`4Ci4=^d=J,?>i;6,7d416,7"), g3);
                                                        goto lab_0x8048e2f;
                                                    }
                                                }
                                            } else {
                                                if (v8 == 3004) {
                                                    // 0x8048c83
                                                    fputs((char *)ft_des("?4d@:,C>8C60G>8:h:Gb4?l,A"), g3);
                                                    goto lab_0x8048e2f;
                                                } else {
                                                    // 0x8048b58
                                                    if (v8 < 3005) {
                                                        // 0x8048c5f
                                                        fputs((char *)ft_des("B8b:6,3fj7:,;bh>D@>8i:6@D"), g3);
                                                        goto lab_0x8048e2f;
                                                    } else {
                                                        // 0x8048ca7
                                                        fputs((char *)ft_des("G8H.6,=4k5J0<cd/D@>>B:>:4"), g3);
                                                        goto lab_0x8048e2f;
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if (v8 == 3010) {
                                            // 0x8048d5b
                                            fputs((char *)ft_des("74H9D^3ed7k05445J0E4e;Da4"), g3);
                                            goto lab_0x8048e2f;
                                        } else {
                                            if (v8 < 3011) {
                                                if (v8 == 3008) {
                                                    // 0x8048d13
                                                    fputs((char *)ft_des("bci`mC{)jxkn<\"uD~6%g7FK`7"), g3);
                                                    goto lab_0x8048e2f;
                                                } else {
                                                    // 0x8048b85
                                                    if (v8 < 3009) {
                                                        // 0x8048cef
                                                        fputs((char *)ft_des("78H:J4<4<9i_I4k0J^5>B1j`9"), g3);
                                                        goto lab_0x8048e2f;
                                                    } else {
                                                        // 0x8048d37
                                                        fputs((char *)ft_des("Dc6m~;}f8Cj#xFkel;#&ycfbK"), g3);
                                                        goto lab_0x8048e2f;
                                                    }
                                                }
                                            } else {
                                                if (v8 == 3012) {
                                                    // 0x8048da3
                                                    fputs((char *)ft_des("8_Dw\"4#?+3i]q&;p6 gtw88EC"), g3);
                                                    goto lab_0x8048e2f;
                                                } else {
                                                    if (v8 < 3012) {
                                                        // 0x8048d7f
                                                        fputs((char *)ft_des("70hCi,E44Df[A4B/J@3f<=:`D"), g3);
                                                        goto lab_0x8048e2f;
                                                    } else {
                                                        switch (v8) {
                                                            case 3013: {
                                                                // 0x8048dc4
                                                                fputs((char *)ft_des("boe]!ai0FB@.:|L6l@A?>qJ}I"), g3);
                                                                goto lab_0x8048e2f;
                                                            }
                                                            case 3014: {
                                                                // 0x8048de5
                                                                fputs((char *)ft_des("g <t61:|4_|!@IF.-62FH&G~DCK/Ekrvvdwz?v|"), g3);
                                                                goto lab_0x8048e2f;
                                                            }
                                                            default: {
                                                                // 0x8048e06
                                                                fwrite((int32_t *)"\nNope there is no token here for you sorry. Try again :)", 1, 56, g3);
                                                                goto lab_0x8048e2f;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            // 0x8048e46
                            if (afterSubstr((int32_t)&v5, (int32_t)"00000000 00:00 0") == 0) {
                                // 0x8048e5e
                                fwrite((int32_t *)"LD_PRELOAD detected through memory maps exit ..\n", 1, 48, g2);
                                v2 = 0;
                                goto lab_0x8048eb2;
                            }
                            v6 = syscall_gets(&v5, 256, v3);
                            v2 = 0;
                            if (v6 == 0) {
                                // break (via goto) -> 0x8048eb2
                                goto lab_0x8048eb2;
                            }
                            // 0x8048a89
                            v7 = isLib(&v5, "libc");
                        }
                        // 0x8048e89
                        v4 = v7 != 0;
                    }
                } else {
                    // 0x8048a57
                    fwrite((int32_t *)"/proc/self/maps is unaccessible, probably a LD_PRELOAD attempt exit..\n", 1, 70, g2);
                    v2 = 1;
                }
            } else {
                // 0x8048a02
                fwrite((int32_t *)"Injection Linked lib detected exit..\n", 1, 37, g2);
                v2 = 1;
            }
        } else {
            // 0x80489b8
            fwrite((int32_t *)"Injection Linked lib detected exit..\n", 1, 37, g2);
            v2 = 1;
        }
    } else {
        // 0x8048992
        puts("You should not reverse this");
        v2 = 1;
    }
    goto lab_0x8048eb2;
  lab_0x8048eb2:;
    int32_t result = v2; // 0x8048ec0
    if (v1 != __readgsdword(20)) {
        // 0x8048ec2
        __stack_chk_fail();
        result = &g4;
    }
    // 0x8048ec7
    return result;
  lab_0x8048e2f:
    // 0x8048e2f
    fputc(10, g3);
    v2 = 0;
    goto lab_0x8048eb2;
}

// --------------- Dynamically Linked Functions ---------------

// void __stack_chk_fail(void);
// int fputc(int c, FILE * stream);
// int fputs(const char * restrict s, FILE * restrict stream);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// char * getenv(const char * name);
// __uid_t getuid(void);
// long int ptrace(enum __ptracerequest __request, ...);
// int puts(const char * s);
// char * strdup(const char * s);

// ------------------ System-Call Functions -------------------

// int32_t open(void);
// ssize_t read(int fd, void * buf, size_t nbytes);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.5.x)
// Detected functions: 7
